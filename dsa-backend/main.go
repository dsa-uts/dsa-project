package main

import (
	"context"
	"database/sql"
	"dsa-backend/background"
	"dsa-backend/handler"
	"dsa-backend/router"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"

	_ "dsa-backend/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	echoSwagger "github.com/swaggo/echo-swagger"
	"github.com/takoyaki65/dsa-project/database"
	"github.com/takoyaki65/dsa-project/database/model"
	"github.com/takoyaki65/dsa-project/database/model/userrole"
	"github.com/uptrace/bun"
	"github.com/uptrace/bun/dialect/pgdialect"
	"github.com/uptrace/bun/driver/pgdriver"
	"github.com/uptrace/bun/extra/bundebug"
	"golang.org/x/crypto/bcrypt"
)

//	@title			DSA Backend API
//	@version		0.0.1
//	@description	This is the API for the DSA Backend application.

//	@host		localhost:8000
//	@BasePath	/api

// @securitydefinitions.oauth2.password	OAuth2Password
// @tokenUrl								/api/user/login
// @scope.me								Grants any rights related to the current user
// @scope.manager							Grants any rights related to manager user
// @scope.admin							Grants any rights related to admin user
func main() {
	r := router.New()

	// Setting up Swagger documentation
	r.GET("/swagger/*", echoSwagger.WrapHandler)

	v1 := r.Group("/api")

	db_user := "dsa_app"
	db_password, err := read_db_password()
	if err != nil {
		r.Logger.Fatalf("Failed to read db password: %v", err)
		return
	}
	// TODO: modify this for production
	db_host := "db:5432"
	dsn := fmt.Sprintf("postgres://%s:%s@%s/dsa_db?sslmode=disable", db_user, db_password, db_host)

	// initialize connection
	sqldb := sql.OpenDB(pgdriver.NewConnector(pgdriver.WithDSN(dsn)))

	// create db instance
	db := bun.NewDB(sqldb, pgdialect.New())
	// For debugging purpose, print all queries to stdout.
	db.AddQueryHook(bundebug.NewQueryHook(bundebug.WithVerbose(true)))

	// Check and create admin user if necessary
	if err := ensureAdminUser(db, r); err != nil {
		r.Logger.Fatalf("Failed to ensure admin user: %v", err)
		return
	}

	// TODO: Initialize JobQueue
	// TODO: Cleaning up some things related to past launches

	// create handler
	h := handler.NewHandler(db)

	// register api routes to router
	h.RegisterRoutes(v1)

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()

	go func() {
		port := ":8000"

		if err := r.Start(port); err != nil && err != http.ErrServerClosed {
			r.Logger.Fatal("shutting down the server: ", err)
			return
		}
	}()

	// Start background process
	go background.ProcessJobQueue(ctx, db, &r.Logger)

	<-ctx.Done()
	r.Logger.Info("Interrupt signal received, shutting down server...")

	// Gracefully shutdown the server with a timeout of 10 seconds.
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := r.Shutdown(shutdownCtx); err != nil {
		r.Logger.Fatal("Server forced to shutdown: ", err)
		return
	}

	r.Logger.Info("Server gracefully stopped")
}

func read_db_password() (string, error) {
	// TODO: modify this to be ready for deploying
	data, err := os.ReadFile("/run/secrets/db_app_password")
	if err != nil {
		return "", fmt.Errorf("failed to read db password: %v", err)
	}
	return strings.TrimSpace(string(data)), nil
}

// Checks if an admin user exists and create one if not
func ensureAdminUser(db *bun.DB, r *echo.Echo) error {
	ctx := context.Background()
	// userStore := storage.NewUserStore(db)
	userStore := database.NewUserStore(db)

	// Check if admin user exists
	adminUsers, err := userStore.GetUserListByUserRole(ctx, userrole.Admin)
	if err != nil {
		return fmt.Errorf("failed to check for admin users: %w", err)
	}

	// If admin user already exists, return early
	if adminUsers != nil && len(*adminUsers) > 0 {
		r.Logger.Info("Admin user already exists")
		return nil
	}

	// If admin user exists more than once, panic because this should not happen
	if adminUsers != nil && len(*adminUsers) > 1 {
		return fmt.Errorf("multiple admin users found, this should not happen")
	}

	// No admin user found, prompt for creation
	r.Logger.Info("No admin user found, creating one admin user...")

	adminInfo, err := readAdminFromSecrets()
	if err != nil {
		return fmt.Errorf("failed to read admin info from secrets: %v", err)
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(adminInfo.Password), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// Create the admin user
	adminUser := &model.UserList{
		UserID:         adminInfo.UserID,
		Name:           adminInfo.Username,
		HashedPassword: string(hashedPassword),
		RoleID:         userrole.Admin,
		DisabledAt:     time.Date(2100, 12, 31, 23, 59, 59, 0, time.UTC),
		Email:          adminInfo.Email,
	}

	if err := userStore.CreateUser(ctx, adminUser); err != nil {
		return fmt.Errorf("failed to create admin user: %w", err)
	}

	log.Printf("Admin user '%s' created successfully", adminInfo.Username)
	return nil
}

func readAdminFromSecrets() (*AdminInfo, error) {
	secretPath := "/run/secrets/admin_info_json"

	// Check if file exists
	if _, err := os.Stat(secretPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("secrets file does not exist: %s", secretPath)
	}

	// Read the JSON file
	data, err := os.ReadFile(secretPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read secret file: %w", err)
	}

	// Parse JSON
	var adminInfo AdminInfo
	if err := json.Unmarshal(data, &adminInfo); err != nil {
		return nil, fmt.Errorf("failed to parse admin info JSON: %w", err)
	}

	validate := validator.New()
	if err := validate.Struct(adminInfo); err != nil {
		return nil, fmt.Errorf("faild to validate admin info: %w", err)
	}

	return &adminInfo, nil
}

// AdminInfo represents the admin user information from Docker secrets
type AdminInfo struct {
	Note     string  `json:"note"`
	UserID   string  `json:"userid" validate:"gt=1"`
	Username string  `json:"username" validate:"gt=1"`
	Password string  `json:"password" validate:"gt=8"`
	Email    *string `json:"email(optional),omitempty"`
}
